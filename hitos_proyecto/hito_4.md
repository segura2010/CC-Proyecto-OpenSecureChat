## Hito 4


En este último hito de la asignatura, se va a mostrar lo que se ha desarrollado a lo largo de cuatrimestre y como se han usado los conocimientos sobre contenedores (concretamente sobre docker) para crear un entorno de pruebas o incluso de producción.

Para crear el entorno de pruebas basado en un contenedor de Docker, se ha creado un Dockerfile para nuestro proyecto. En este Dockerfile se describe el sistema operativo que correrá en el contenedor (en nuestro caso Ubuntu 14.04), los servicios necesario (indicando los comandos necesarios para instalarlos), los puertos que podrían ser necesarios para acceder a algunos de estos servicios (órdenes EXPOSE del Dockerfile) y los volúmenes necesarios para alojar los datos persistentes (orden VOLUME). En caso de Docker, esto último es necesario si queremos que nuestro contenedor guarde de forma persistente los datos que se van añadiendo a nuestras bases de datos, pues por defecto al apagar el contenedor los datos se pierden.

Para nuestro proyecto podemos ver el Dockerfile que se ha desarrollado en: [https://github.com/segura2010/CC-Proyecto-OpenSecureChat/blob/master/Dockerfile](https://github.com/segura2010/CC-Proyecto-OpenSecureChat/blob/master/Dockerfile). En este Dockerfile se incluye todo lo necesario para que se instalen todos los componentes necesarios para que nuestra aplicación funcione correctamente. En la parte final podemos ver que se ha optado por que nuestro Dockerfile descargue la última versión de la rama de producción de nuestro repositorio para que siempre este actualizado en lugar de añadir a la imagen una versión concreta. También se ha añadido la línea `RUN ln -s /usr/bin/nodejs /usr/bin/node` para arreglar un problema con la versión de NodeJS, ya que el ejecutable se invocaba con `nodejs` en lugar de con `node`.

Como se ha comentado antes, se indica con las órdenes EXPOSE y VOLUME que es necesario exponer los puertos indicados para acceder a los servicios pertienentes o indicar un volumen para guardar de forma persistente los datos de nuestras bases de datos, sin embargo, Docker no utiliza estás órdenes y deberá ser el usuario que ejecute el contenerdor el que use las opciones -v y -p para que ambas cosas funcionen. La opción -v nos permite indicar el directorio de la máquina host que se montará para guardar de forma persistente los datos que se alojen en el directorio indicado del contenedor. Por ejemplo: `docker run -v /data/db:/data/db proyecto/osc`. Con este comando al iniciar el contenedor, le indicamos que utilice el directorio /data/db de nuestro host (directorio delante de los :) para alojar la información del directorio /data/db de nuestro contenedor (directorio detrás de los :). De esta forma podemos guardar datos de forma persistente. Igual hariamos para exponer los puertos del contenedor usando la opción -p: `docker run -p 80:3000 -p 27017:27017 proyecto/osc`. Con el comando anterior, podemos redireccionar los puertos 3000 y 27017 de nuestro contenedor (correspondientes a la aplicación web y a MongoDB) a los puertos 80 y 27017 de nuestra máquina host.

Por tanto, usando este Dockerfile solamente será necesario ejecutar `docker build -t production/osc .` para construir el contenedor a partir del Dockerfile. La opción -t le dará un tag a nuestro contenedor y el punto final indica que el Dockerfile está en el directorio actual. Si el Dockerfile estuviese en otro directorio usaríamos `docker build -t production/osc path/to/Dockerfile`. Una vez construido el contenedor con nuestra aplicación solamente tendremos que ejecutarla con `docker run production/osc`, e indicando los puertos y volúmenes que deseemos usar; como ya se ha indicado anteriormente.

A partir del Dockerfile, se ha creado un entorno de pruebas con un contenedor en el servicio Bluemix. Para ello, se ha seguido la documentación proporcionada por IBM ([https://www.eu-gb.bluemix.net/docs/containers/container_single_ov.html](https://www.eu-gb.bluemix.net/docs/containers/container_single_ov.html)). No es difícil añadir el contenedor a Bluemix, usando la herramienta que proporcionan de Cloud Foundry, simplemente tenemos que crear el contendor como si lo estuviesemos creando con Docker pero usando `cf ic build -t tag path/to/Dockerfile`. Deberemos haber iniciado sesión con nuestra cuenta antes de usar el comando anterior. Una vez que crea la imagen (debemos tener paciencia porque tarda bastante), ya la tendremos a nuestra disposición en el panel de control de Bluemix. De esta forma, podremos utilizar dicha imagen para crear tantos contenedores como deseemos.

La dirección para acceder al contenedor públicado en Bluemix es: http://osc.eu-gb.mybluemix.net/

Para esta entrega final se ha añadido nueva funcionalidad a nuestra aplicación. Ahora es posible enviar mensajes y archivos entre usuarios. Ya es posible utilizar la funcionalidad principal de la aplicación. Solamente es necesario registrarse y crear nuevos chats con otros usuarios a partir del nombre de usuario. Todos los mensajes se cifran en el navegador del usuario usando la clave pública de usuario receptor, de forma que solamente los usuario del chat pueden descifrar sus mensajes y sus ficheros (solo se pueden subir ficheros menores de 800KB). Además, se ha añadido soporte para PushBullet ([http://pushbullet.com/](http://pushbullet.com/)), por lo que el usuario podrá conectar su cuenta en dicha plataforma para recibir notificaciones de nuevos mensajes en sus dispositivos. Para añadir esta posibilidad, se deben configurar las variables de entorno siguientes:

- PUSH_CLIENT_ID: Identificador de aplicación que debes solicitar en la web para aplicaciones de PushBullet para tu aplicación
- PUSH_CLIENT_SECRET: Token secreto que debes solicitar en la web para aplicaciones de PushBullet
- PUSH_REDIRECT_URL: Dirección a la que se redireccionará al usuario una vez que acepta el uso de PushBullet (a esta url llega el Token para usarlo para enviar las notificaciones). Se debe usar una url de la forma http://dominio/auth.html.

En https://docs.pushbullet.com/ podemos ver toda la información sobre los tokens de sesión y demás posibilidades de la API. También podremos acceder a la creación de nuestras aplicaciones para obtener los datos necesarios.

En definitiva, se ha conseguido añadir la funcionalidad principal al proyecto, por lo que es usable. Me gustaría seguir añadiendo funcionalidad en el futuro en mi tiempo libre, principalmente chats en grupo y aprender como añadir HTTPS (usando [Let's Encrypt](https://letsencrypt.org)).